我打算在这个部分写我的题解报告,我做题不是为了追求数量,而是真正想
学一点算法知识,想提高自己的算法水平.所以写题解也是必要的.
最近学得新知识有点多,我感觉已经在边学边忘的道路上了.



2122 HDU Today
算是一个裸的dijkstra 算法了.但是我在这个题目上跪了很久,好像是很sb的原因,但是又忘了
是跪在哪里.好像其中一个原因是因为我的 map 没有clear.后面发现了这个问题,还是会跪.
对了,问题可能是这个. 对于 一个map<string, int> table. 新插入一个item之后,table[item]
是等于0的.如果两个地方在后面的地方都没有出现过,那么返回-1. 就是这种情况.如果两个
地方(出发地 和 目的地)如果是一样的,那么返回0.如果不一样,那么返回-1.而我在程序中没有
正对原始数据做判断,而是根据 talbe[s] table[t] 来判断,这样如果是两个都没有在下文中出
现过的地方,那么我的程序就错了.就是这个地方我跪了好多次,这个题就这样破了记录.
dijkstra 已经不再重要,重要的是我的心态.


1166 敌兵布阵
这是我学习线段数的开始,当然这个题目还有树状数组的解法,貌似我也学习了一下,但是现在
树状数组的解法我一点也想不起来了.但是程序还在,认真读下应该还是可以搞明白的.
首先说说树状数组吧,显示建数,我习惯用的是数组的表示方法.一个查找方法.还有就是 update
方法.一般来说,一个完整的线段树就包括这3部分吧.程序的实现基本都是递归的实现,也算不上
太复杂,基本可以搞定.

1394 Minimum Inversion Number
这实际上是一个和逆序数相关的一个题目,我觉着这个题目是考察逆序树的性质,而不是算法
设计,对于将数组中的第一个数字,放在数组的最后一位之后,整个数列的逆序数的变化公式是
,核心公式是
sum = sum - ps[i] - ps[i] + n-1;


1542 线段树求矩形并面积
构造空线段树, 设置标记,矩形的右边的cover 设置成1, 左边设置成-1.
输入矩形实际上是输入边,这些边输入完毕后,按照x坐标将所有的线段排序.
然后每次插入一条线段,计算出增加的面积,当m-1条线段都插入完毕后,计算
出的就是所有的矩形面积了.

更重要的是看明白程序的计算过程,面积的计算过程就是
插入线段,计算面积,插入,计算.---->结束.

4271 black hand
这个是编辑距离.这个稍有点变化.但是总体来说就是一个编辑距离的问题.编辑距离的计算属于
dp, 状态转移方程是: dp[i][j] = min(dp[i-1][j-1]+cost, dp[i-1][j]+1, dp[i][j-1]+1);
当然,各种转移状态的cost可能不同,根据具体情况计算代价啊即可.
但是这个题目还是有一点不同的,需要灵活应用算法.学着控制程序.
